import time
import json
import sys

import scipy.signal
import numpy as np
from numpy.random import PCG64

from Module.module import Generator
from Module.functions import gauss, butterworth_filter

class signal_butterworth_smooothed_baseline(Generator):
    '''
    # signal generator using butterwoth filter as the noise smoother
    
    ## Process
    1. add baseline
        1. add noise signal
        1. smooth the noise signal by lowpassfilter(for here, it's butterworth filter)
    1. add peaks
    1. add noise
    '''
    
    def __init__(self, length:int=None) -> None:
        self.rnd_gen = np.random.Generator(PCG64(int(time.time())))
        self.signal = np.zeros(length)
        self.baseline = None
        self.length = length
        self.peak_pos = []
        pass
    
    def add_peaks(self, pos, amp, sigma, label_ci:float = 2):
        
        if len(pos) != len(amp) or len(pos) != len(sigma) or len(amp) != len(sigma):
            raise
            
        pos = super().relocated_peaks(pos, sigma)
        for i in range(len(pos)):
            # print(amp[i], np.max(self.add_peak(pos[i], amp[i], sigma[i])))
            self.signal = self.signal + self.add_peak(pos[i], amp[i], sigma[i])
            
            if 3 < label_ci:
                label_ci = 3
                
            start = int(pos[i] - sigma[i]*label_ci)
            end = int(pos[i] + sigma[i]*label_ci)
            if start < 0:
                start = 0
            elif self.length - 2 < end:
                end = int(self.length - 1)
            self.peak_pos.append([start, int(pos[i]), end])
        
        self.peak_num = len(pos)
        return self
    
    def add_baseline(self, length:int, height:float, std:float, sp, fp, fs, gpass, gstop):
        baseline = self.rnd_gen.normal(height, std, (length))
        baseline = self.add_filter(baseline, sp, fp, fs, gpass, gstop)
        self.baseline = baseline
        self.signal = baseline
        return self
    
    def add_filter(self, signal_val, sampling_rate, fp, fs, gpass, gstop):
        """
        ## Butterworth filter (lowpass filter) fuction
        ## Parameters
            - signal_val: signal
            - sampling_rate: 波形のサンプリングレート
            - fp: 通過域端周波数[Hz]
            - fs: 阻止域端周波数[Hz]
            - gpass: 通過域端最大損失[dB] passband ripple 
            - gstop: 阻止域端最小損失[dB] stopband attenuation
            - curve: 減衰関数  
                - linear: 線形減衰
        """
        return butterworth_filter(signal_val, sampling_rate, fp, fs, gpass, gstop)
    
    def add_noise(self, signal:np.ndarray = None, length:int = None, max_height:float = None, stn: float = None, sigma:float = 1.0):
        
        if signal is not None:
            length = len(signal)
        if signal is None and length is None:
            length = len(self.signal)
        
        if stn is not None and signal is not None:
            max_height = np.max(signal) * stn
        
        if max_height is not None:
            noise = self.rnd_gen.normal(0, sigma, length)
            noise_max = np.max(noise) if np.max(noise) > np.abs(np.min(noise)) else np.abs(np.min(noise))
            noise = (noise + noise_max) * max_height / noise_max / 2
            self.signal = self.signal + noise

        if stn is not None:
            length = len(self.signal)
            noise = self.rnd_gen.normal(0, sigma, length)
            signal_max = np.max(self.signal)
            noise_max = np.max(noise) if np.max(noise) > np.abs(np.min(noise)) else np.abs(np.min(noise))
            noise_min = np.min(noise)
            noise = (noise - noise_min) * signal_max / (noise_max * stn * 2)
            self.signal = self.signal + noise
            
        return self
    
    def add_peak(self, pos, amp, sigma):
        peak_value = gauss(np.arange(0, self.length, 1), pos, amp, sigma)
        # self.signal = self.signal + peak_value
        return peak_value
    
    @property
    def get_signal(self):
        return self.signal
    @property
    def get_baseline(self):
        return self.baseline
    @property
    def get_peak_pos(self):
        return self.peak_pos
    @property
    def get_peak_num(self):
        return self.peak_num
    
    def init(self):
        self.signal = np.zeros(self.length)
        self.baseline = np.zeros(self.length)
        self.peak_num = None
        self.peak_pos = []

def sequence_generator(param_dict:dict, log_conf_path:str = None):
    '''
    # function to generate simulated spectra dataset
    ## params
        - dict: dataset generation params.
        - log_conf_path: path to the log file which stores logs while the datset generation in progress.
    ## Process to make simulated spectrum
    1. add baseline
    1. apply butterworth filter(to smooth the baseline generated by numpy random)
    1. add peaks
    1. add noise
    '''
    import os
    import shutil
    import time
    from tqdm import tqdm
    import json
    from logging import getLogger, config
    
    if log_conf_path is None:
        raise
    
    spectrum_num = param_dict["spectrum_num"]
    width = param_dict["width"]
    label_ci = param_dict["label_ci"]
    baseline_height_range = param_dict["baseline_height_range"]
    std_range = param_dict["std_range"]
    sprate_range = param_dict["sprate_range"]
    fp_range = param_dict["fp_range"]
    fs_range = param_dict["fs_range"]
    gpass_range = param_dict["gpass_range"]
    gstop_range = param_dict["gstop_range"]
    peak_num_range = param_dict["peak_num_range"]
    pos_range = param_dict["pos_range"]
    amp_range = param_dict["amp_range"]
    sigma_range = param_dict["sigma_range"]
    stn_range = param_dict["stn_range"]
    dataset_id = param_dict["dataset_id"]
    dataset_dir_root = param_dict["dataset_dir"]
    dataset_dir = dataset_dir_root+f"/{dataset_id}/"
    height_limit = param_dict["height_limit"]
    seed = param_dict["seed"]
    
    with open(log_conf_path, 'r') as f:
        log_conf = json.load(f)
        log_conf["handlers"]["fileHandler"]["filename"] = f"../log/dataset_gen_log_{dataset_id}"
    config.dictConfig(log_conf)
    logger = getLogger(__name__)
    logger.info("simulated spectra dataset generation just started!")
    
    if not os.path.exists(dataset_dir):
        os.makedirs(dataset_dir, exist_ok=True)
    
    if param_dict["reset_dataset"] == True:
        shutil.rmtree(dataset_dir)
        os.makedirs(dataset_dir, exist_ok=True)
    
    if seed == "time":
        seed = int(time.time())
        rnd_params_gen = np.random.Generator(PCG64(seed))
    else:
        rnd_params_gen = np.random.Generator(PCG64(int(param_dict["seed"])))
    
    n_peaks = []
    signal = signal_butterworth_smooothed_baseline(length=width)
    
    for i in tqdm(range(spectrum_num)):
        
        rnd_params = rnd_params_gen.random(12)
        peak_num = rnd_params_gen.integers(low=peak_num_range[0], high=peak_num_range[1]+1)
        pos_list = rnd_params_gen.random(peak_num)
        pos_list = (pos_range[0] + pos_list*(pos_range[1] - pos_range[0]))*width
        amp_list = rnd_params_gen.random(peak_num)
        amp_list = amp_range[0] + amp_list*(amp_range[1] - amp_range[0])
        sigma_list = rnd_params_gen.random(peak_num)
        sigma_list = sigma_range[0] + sigma_list*(sigma_range[1] - sigma_range[0])
        
        baseline_height = baseline_height_range[0] + rnd_params[0]*(baseline_height_range[1]-baseline_height_range[0])
        std = std_range[0] + rnd_params[1]*(std_range[1] - std_range[0])
        sampling_rate = sprate_range[0] + rnd_params[2]*(sprate_range[1]-sprate_range[0])
        fp = fp_range[0] + rnd_params[3]*(fp_range[1]-fp_range[0])
        fs = fs_range[0] + rnd_params[4]*(fs_range[1]-fs_range[0])
        gpass = gpass_range[0] + rnd_params[5]*(gpass_range[1]-gpass_range[0])
        gstop = gstop_range[0] + rnd_params[6]*(gstop_range[1]-gstop_range[0])
        stn = stn_range[0] + rnd_params[7]*(stn_range[1]-stn_range[0])
        
        signal = signal.add_baseline(width, baseline_height, std, sampling_rate, fp, fs, 
                                        gpass, gstop)
        signal = signal.add_peaks(pos_list, amp_list, sigma_list)
        signal = signal.add_noise(stn=stn)
        
        label = np.zeros(width)
        peak_pos = signal.get_peak_pos
        
        if 1 <= len(peak_pos):
            for peak in peak_pos:
                label[peak[0]:peak[2]] = 1
        
        np.savez(dataset_dir+f"signal{i}", x=signal.get_signal, y=label)
        n_peaks.append(signal.get_peak_num)
        
        signal.init()
    
    param_dict["seed"] = seed
    with open(dataset_dir_root+f"/config_{dataset_id}.json", 'w') as f:
        json.dump(param_dict, f, indent=4)
    
    logger.info("Generation process normaly finished!")
    return dataset_dir, np.array(n_peaks)